<!DOCTYPE html>
<!--
	Web 2.0, CTU course slides
	(cc) 2010-2013 Tomas Vitvar, tomas@vitvar.com
-->
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="course" content="Web 2.0" />
	<meta name="lecture" content="Lecture 6" />
	<meta name="keywords" content="polling, long-polling, WebSockets, new I/O" />

	<link type="text/css" rel="stylesheet" href="css/meta.css">
	</link>
	<link type="text/css" rel="stylesheet" href="css/ctu-fit.css">
	</link>
	<link type="text/css" rel="stylesheet" href="humla/lib/core/humla.css">
	</link>

	<script type="text/javascript" src="humla/lib/humla.js"></script>
	<title>Protocols for the Realtime Web</title>
</head>

<body>

	<footer>
		<p><b>#META_LECTURE#: #TITLE#</b>,&nbsp;<span class="meta_semester" />,&nbsp;
			<span class="meta_twitter" /></p>
		<p><b>&#8210; #SLIDE_NO# &#8210;</b></p>
	</footer>

	<div class="slide intro">
		<hgroup>
			<h1><span class="meta_course" /></h1>
			<h2>#META_LECTURE#: #TITLE#</h2>
		</hgroup>
		<div class="author">
			<p class="meta_author" />
			<p><span class="meta_email" /> &bull; <span class="meta_twitter" /> &bull;
				<span class="meta_web" /></p>
		</div>
		<center>
			<div class="meta_logo"></div>
		</center>
		<div class="org">
			<p class="meta_org" />
			<p><span class="meta_orgfac" /> &bull; <span class="meta_field" />
				&bull; <span class="meta_orgweb" /></p>
		</div>
		<div class="etc">
			<div class="text-info">
				Modified: #LAST_MODIFIED#<br />
				Humla v#HUMLA_VERSION#
			</div>
			<a href="http://creativecommons.org/licenses/by-sa/3.0/">
				<div class="license"></div>
			</a>
			<div class="oppa"></div>
		</div>
	</div>

	<div class="slide">
		<hgroup>
			<h1>Overview of APIs and Protocols</h1>
		</hgroup>
		<style>
			.custom_table tbody tr td { padding-top: 7px; padding-bottom: 7px }
		</style>
		<table class="prettytable custom_table" style="margin-left: 50px; margin-top: 30px; margin-bottom: 30px; width: 700px">
			<caption>APIs and Protocols</caption>
			<thead>
				<tr>
					<th width="200px"></th>
					<th>XMLHttpRequest</th>
					<th>Server-Sent Events</th>
					<th>WebSocket</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>Request streaming</td>
					<td>no</td>
					<td>no</td>
					<td>yes</td>
				</tr>
				<tr>
					<td>Response streaming</td>
					<td>limited</td>
					<td>yes</td>
					<td>yes</td>
				</tr>
				<tr>
					<td>Framing mechanism</td>
					<td>HTTP</td>
					<td>event stream</td>
					<td>binary framing</td>
				</tr>
				<tr>
					<td>Binary data transfers</td>
					<td>yes</td>
					<td>no (base64)</td>
					<td>yes</td>
				</tr>
				<tr>
					<td>Compression</td>
					<td>yes</td>
					<td>yes</td>
					<td>limited</td>
				</tr>
				<tr>
					<td>App. transport protocol</td>
					<td>HTTP</td>
					<td>HTTP</td>
					<td>WebSocket</td>
				</tr>
				<tr>
					<td>Net. transport protocol</td>
					<td>TCP</td>
					<td>TCP</td>
					<td>TCP</td>
				</tr>
			</tbody>
		</table>
		<!-- 
		
		<img style="padding: 10px 0 0 10px" src="img/APIs-protocols.png"></img> -->
	</div>

	<div class="slide outline"></div>

	<section>
		<header>Streaming and Long-polling</header>

		<div class="slide">
			<hgroup>
				<h1>Pushing and Polling</h1>
			</hgroup>
			<div id="1TXuRmtQIG5wJtioixp-dizSX_TguDBJwE5WoYpCyQnE" class="h-drawing" style="height: 200px"></div>
			<ul class="xx-small">
				<li>Conceptual basis in messaging architectures</li>
				<ul>
					<li>event-driven architectures (EDA)</li>
				</ul>
				<li><b>HTTP is a request-response protocol</b></li>
				<ul>
					<li>response cannot be sent without request</li>
					<li>server cannot initiate the communication</li>
				</ul>
				<li><b>Polling</b> &ndash; client periodically checks for updates on the server</li>
				<li><b>Pushing</b> &ndash; updates from the server (also called COMET)<br />
					= <b>long polling</b> &ndash; server holds the request for some time<br />
					= <b>streaming</b> &ndash; server sends updates without closing the socket</li>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>HTTP Streaming</h1>
			</hgroup>
			<div id="1j6nE63Ed5zVDIgUVJeool8t9mWHtPsrs8e356Wc0b3E" class="h-drawing" style="height: 280px"></div>
			<ul class="xx-small">
				<li>server deffers the response until an event or timeout is available</li>
				<li>when an event is available, server sends it back to client as part of
					the response; this does not terminate the connection</li>
				<li>server is able to send pieces of response w/o terminating the conn.</li>
				<ul>
					<li>using <code>transfer-encoding</code> header in HTTP 1.1</li>
					<li>using End of File in HTTP 1.0<br />
						(server omits <code>content-lenght</code> in the response)</li>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Chunked Response</h1>
			</hgroup>
			<ul class="x-small">
				<li>Transfer encoding <code>chunked</code></li>
				<ul>
					<li>It allows to send multiple sets of data over a single connection</li>
					<li>a chunk represents data for the event</li>
					<pre class="brush: plain">
						HTTP/1.1 200 OK
						Content-Type: text/plain
						Transfer-Encoding: chunked

						25
						This is the data in the first chunk 

						1C
						and this is the second one 

						0</pre>
					<li>Each chunk starts with hexadecimal value for length</li>
					<li>End of response is marked with the chunk length of 0</li>
				</ul>
				<li>Steps:</li>
				<ul>
					<li>server sends HTTP headers and the first chunk (step 3)</li>
					<li>server sends second and subsequent chunk of data (step 4)</li>
					<li>server terminates the connection (step 5)</li>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Issues with Chunked Response</h1>
			</hgroup>
			<ul class="small">
				<li>Chunks vs. Events</li>
				<ul>
					<li>chunks cannot be considered as app messages (events)</li>
					<li>intermediaries might "re-chunk" the message stream<br />
						&rarr; e.g., combining different chunks into a longer one</li>
				</ul>
				<li>Client Buffering</li>
				<ul>
					<li>clients may buffer all data chunks before they make the response
						available to the client application</li>
				</ul>
				<li>HTTP streaming in browsers</li>
				<ul>
					<li>Server-sent events</li>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>XHR Polling</h1>
			</hgroup>
			<ul class="xx-small">
				<li>Client is making a period checks</li>
				<pre class="brush: javascript">
					function checkUpdates(url) {
						var xhr = new XHMLHttpRequest();
						xhr.open('GET', url);
						xhr.onload = function() { ... };
						xhr.send()
					}
					
				  setInterval(function() { checkUpdates('/updates', 60000)});</pre>				
				<ul>
					<li>When new data is available, data is returend</li>
					<li>When no data is available, the response is empty</li>
					<li>Simple to implement but very inefficient</li>
				</ul>
				<li>Polling is expensive when interval is small</li>
				<ul>
					<li>Each XHR reqquest is a standalone HTTP request</li>
					<li>HTTP incurs ~850 bytes of overhead for request/response headers</li>
					<li>For example, 10 000 clients, each polling with 60 seconds interval:</li>
					<ul>
						<li class="no-bullet"><code>(850 bytes x 8 bits x 10000)/60 seconds = 1.13 Mbps</code></li>
						<li class="no-bullet">Server process 167 requests per second at a rate of 1.13 Mbps throughput</li> 
					</ul>
					<li>Message latency</li>
					<ul>
						<li>Depends on the interval, maximum is 60 seconds</li>
						<li>Decreasing the interval will put more overhead on the server</li>
					</ul>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>XHR Long Polling</h1>
			</hgroup>
			<div id="1-YIqxkEw22GP7dIa0uqKbEpVzuCQt8yeJLMhiFiPGrs" class="h-drawing" style="height: 260px"></div>
			<ul class="xx-small">
				<li>Server holds long-poll requests</li>
				<ul>
					<li>server responds when an event or a timeout occurs</li>
					<li>saves computing resources at the server as well as network resources</li>
					<li>can be applied over HTTP persistent and non-persistent communication</li>
				</ul>
				<li>Advantages and Issues</li>
				<ul>
					<li>Better message latency when interval is not constant</li>
					<li>concurrent requests processing at the server</li>
					<li>Too many messages may result in worse results that XHR polling</li>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Server-Sent Events</h1>
			</hgroup>
			<ul class="x-small">
				<li>W3C specification</li>
				<ul>
					<li>part of HTML5 specs, see <span id="w3c-sse" class="h-ref"></span></li>
					<li>API to handle HTTP streaming in browsers by using DOM events</li>
					<li>transparent to underlying HTTP streaming mechanism</li>
					<ul>
						<li>can use both chunked messages and EOF</li>
					</ul>
					<li>same origin policy applies</li>
				</ul>
				<li><code>EventSource</code> interface</li>
				<ul>
					<li>event handlers: <code>onopen</code>, <code>onmessage</code>, <code>onerror</code></li>
					<li>constructor <code>EventSource(url)</code> &ndash; creates and opens the stream</li>
					<li>method <code>close()</code> &ndash; closes the connection</li>
					<li>attribute <code>readyState</code></li>
					<ul>
						<li><code>CONNECTING</code> &ndash; The connection has not yet been established, or it was
							closed and the user agent is reconnecting.</li>
						<li><code>OPEN</code> &ndash; The user agent has an open connection and is dispatching
							events as it receives them.</li>
						<li><code>CLOSED</code> &ndash; The conn. is not open, the user agent is not
							reconnecting.</li>
					</ul>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>SSE Example</h1>
			</hgroup>
			<ul class="x-small">
				<li>Initiating <code>EventSource</code></li>
				<pre class="brush: javascript; class-name: 'tight'">
					if (window.EventSource != null) {
					  var source = new EventSource('your_event_stream.php');
					} else {
					  // Result to xhr polling :(
					}</pre>
				<li>Defining event handlers</li>
				<pre class="brush: javascript">
					source.addEventListener('message', function(e) {
					  // fires when new event occurs, e.data contains the event data
					}, false);
					
					source.addEventListener('open', function(e) {
					  // Connection was opened
					}, false);
					
					source.addEventListener('error', function(e) {
					  if (e.readyState == EventSource.CLOSED) {
						// Connection was closed
					  }
					}, false);</pre>
				<ul class="small">
					<li>when the conn. is closed, the browser reconnects every ~3 seconds</li>
					<ul>
						<li>can be changed using <code>retry</code> attribute in the message data</li>
					</ul>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Event Stream Format</h1>
			</hgroup>
			<ul class="x-small">
				<li>Format</li>
				<ul>
					<li>response's <code>content-type</code> must be <code>text/event-stream</code></li>
					<li>every line starts with <code>data:</code>, event message terminates with 2 <code>\n</code> chars.</li>
					<li>every message may have associated <code>id</code> (is optional)</li>
					<pre class="brush: plain">
						id: 12345\n
						data: first line\n
						data: second line\n\n</pre>
				</ul>
				<li>JSON data in multiple lines of the message</li>
				<ul>
					<pre class="brush: plain">
						data: {\n
						data: "msg": "hello world",\n
						data: "id": 12345\n
						data: }\n\n</pre>
				</ul>
				<li>Changing the reconnection time</li>
				<ul>
					<li>default is 3 seconds</li>
					<pre class="brush: plain">
						retry: 10000\n
						data: hello world\n\n</pre>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Auto-reconnect and Tracing</h1>
			</hgroup>
			<ul class="x-small">
				<li>When a connection is dropped</li>
				<ul>
					<li><code>EventSource</code> will automatically reconnect</li>
					<li>It may advertise the last seen message ID</li>
					<ul>
						<li>The client appends <code>Last-Event-ID</code> header in the reconnect request</li>
					</ul>
					<li>The stream can be resumed and lost messages can be retransmitted</li>
				</ul>
				<li>Example</li>
				<pre class="brush: plain; class-name: 'tight'">
        id: 43 
        data: ...

        => Request (after connection is dropped)
        GET /stream HTTP/1.1 
        Host: example.com
        Accept: text/event-stream
        Last-Event-ID: 43

        <= Response
        HTTP/1.1 200 OK 
        Content-Type: text/event-stream
        Connection: keep-alive
        Transfer-Encoding: chunked

        id: 44 
        data: ...</pre>				
			</ul>
		</div>


		<div class="slide">
			<hgroup>
				<h1>SSE Server-side implementation</h1>
			</hgroup>
			<ul class="x-small">
				<li>Java Servlet</li>
				<ul>
					<li>method <code>doGet</code></li>
				</ul>
				<pre class="brush: java">
					public void doGet(HttpServletRequest req, HttpServletResponse resp)
					    throws IOException {
					
					    // set http headers
					    resp.setContentType("text/event-stream");
					    resp.setHeader("cache-control", "no-cache");
					
						// current time in milliseconds
					    long ms = System.currentTimeMillis(); 

					    // push data to the client for 20 seconds
					    // client should reconnect when the connection is closed
					    while (System.currentTimeMillis() - ms < 20000) {
					        resp.getWriter().print("data: servlet runs for " + 
					            (System.currentTimeMillis() - ms)/1000 + " seconds.\n\n");
					        resp.getWriter().flush();
					        try {
					            Thread.sleep(4000);
					        } catch (InterruptedException e) {
					            // do nothing;
					        }
					    }
					}</pre>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Streams API</h1>
			</hgroup>
			<ul class="small">
				<li>An experimental technology, a living standard</li>
				<li>JavaScript API to programmatically access streams of data</li>
				<ul>
					<li>Before, the whole resource had to be read</li>
					<li>Now, you can process raw data as soon as it is available</li>
					<ul>
						<li>No need to generate string or buffer</li>
						<li>Detect streams start and end</li>
						<li>Chain streams together</li>
						<li>Handle errors, cancel streams</li>
					</ul>
				</ul>
				<li>Streams usage</li>
				<ul>
					<li>Responses can be available as streams using Fetch API</li>
					<ul>
						<li>Response body returned by a <code>fetch</code> request and exposed as <code>ReadableStream</code></li>
						<li>You can read it using <code>ReadableStream.getReader()</code></li>
						<li>You can cancel it using <code>ReadableStream.cancel()</code></li>
					</ul>
				</ul>
			</ul>
		</div>

		<!--<div class="slide">
				<hgroup>
					<h1>Demo</h1>
				</hgroup>
				<ul>
					<li>Example Server-sent events demo</li>
					<ul class="small" style="zoom: 0.9; margin-bottom: 20px">
						<li>requires a server running at <code style="zoom: 0.9">http://demo-sse.vitvar.com:8080</code></li>
						<li>runs in <code>iframe</code>, same origin policy applies</li>
						<li>call <code>http://demo-sse.vitvar.com:8080/echo?msg=text</code>,<br/>
						&rarr; the message should be displayed as event</li>
					</ul>
					<input id="btn" type="button" onclick="javascript:run_stop_demo()" value="Run Demo"></input>&nbsp;
					<input type="button" onclick="javascript:generateEvent()" value="Generate Event"></input>
					<input id="event" type="text" value="sample text" style="width: 300px"></input><br/>
					
					<script>
						var demoURL = "http://demo-sse.vitvar.com:8080";
						
						function run_stop_demo() {
							fr = document.getElementById("if-sse");
							bt = document.getElementById("btn");
							if (bt.value == "Run Demo") {
								fr.src = demoURL;
								bt.value = "Stop Demo";
							} else {
								fr.src = "";
								bt.value = "Run Demo";
							}
						}
						
						function generateEvent() {
							fr = document.getElementById("if-gev");
							fr.src = demoURL + "/echo?msg=" + document.getElementById("event").value;
						}
						
					</script>
					
					<iframe id="if-sse" style="width: 620px; margin-top: 10px; height: 270px; 
					  border: 1px solid silver"></iframe>
					<iframe id="if-gev" style="display: none"></iframe>
			</div>-->

		<div class="slide">
			<hgroup>
				<h1>Other Technologies</h1>
			</hgroup>
			<ul class="x-small">
				<li>Cross-document messaging</li>
				<div id="1DRm9FfN_CyiaYCccFkFOrcygsrwF_cpy7gKg6gEscEU" style="height: 165px" class="h-drawing"></div>
				<ul style="margin-top: 10px">
					<li>The use of Cross Document Messaging for streaming</li>
					<ul class="no-bullet">
						<li>1. The client loads a streaming resource in a hidden <code>iframe</code></li>
						<li>2. The server pushes a JavaScript code to the <code>iframe</code></li>
						<li>3. The browser executes the code as it arrives from the server</li>
						<li>4. The embedded iframe's code posts a message to the upper document</li>
					</ul>
				</ul>
			</ul>
		</div>

	</section>

	<div class="slide outline"></div>

	<section>
		<header>WebSocket Protocol</header>

		<div class="slide">
			<hgroup>
				<h1>WebSocket</h1>
			</hgroup>
			<ul class="xx-small">
				<li>Specifications</li>
				<ul>
					<li>IETF defines <span id="websocket" class="h-ref"></span></li>
					<li>W3C defines <span id="websocket-w3c" class="h-ref"></span></li>
				</ul>
				<li>Design principles</li>
				<ul>
					<li>a new protocol</li>
					<ul>
						<li>browsers, web servers, and proxy servers need to support it</li>
					</ul>
					<li>a layer on top of TCP</li>
					<li>bi-directional communication between client and servers</li>
					<ul>
						<li>low-latency apps without HTTP overhead</li>
					</ul>
					<li>Web origin-based security model for browsers</li>
					<ul>
						<li>same origin policy, cross-origin resource sharing</li>
					</ul>
					<li>support multiple server-side endpoints</li>
				</ul>
        <li>Custom URL scheme: <code>ws</code> and <code>wss</code> (TCP and TLS)</li>
        <ul>
          <li>WebSocket can be used over non-HTTP connections outside of browsers</li>
        </ul>        
				<li>Options to establish a WebSocket connection</li>
				<ul>
          <li>TLS and ALPN</li>
					<li>HTTP/1.1 connection upgrade</li>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Connection Upgrade &ndash; Request</h1>
			</hgroup>
			<ul class="small">
				<li>Request</li>
				<ul>
					<li>client sends a following HTTP request to upgrade the connection to WebSocket</li>
					<pre class="brush: plain">
						GET /chat HTTP/1.1
						Host: server.example.com
						Upgrade: websocket
						Connection: Upgrade
						Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
						Sec-WebSocket-Origin: http://example.com
						Sec-WebSocket-Protocol: chat, superchat
						Sec-WebSocket-Version: 7</pre>
					<li><code>Connection</code> &ndash; request to upgrade the protocol</li>
					<li><code>Upgrade</code> &ndash; protocol to upgrade to</li>
					<li><code>Sec-WebSocket-Key</code> &ndash; a client key for later validation</li>
					<li><code>Sec-WebSocket-Origin</code> &ndash; origin of the request</li>
					<li><code>Sec-WebSocket-Protocol</code> &ndash; list of sub-protocols that client supports (proprietary)</li>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Connection Upgrade &ndash; Response</h1>
			</hgroup>
			<ul class="xx-small">
				<li>Response</li>
				<ul>
					<li>server accepts the request and responds as follows</li>
					<pre class="brush: plain">
						HTTP/1.1 101 Switching Protocols
						Upgrade: websocket
						Connection: Upgrade
						Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
						Sec-WebSocket-Protocol: chat</pre>
					<ul>
						<li><code>101 Switching Protocols</code> &ndash; status code for a successful upgrade</li>
						<li><code>Sec-WebSocket-Protocol</code> &ndash; a sub-protocol that the server selected
							from the list of protocols in the request</li>
						<li><code>Sec-WebSocket-Accept</code> &ndash; a key to prove it has received a client
							WebSocket handshake request</li>
					</ul>
					<li>Formula to compute <code>Sec-WebSocket-Accept</code></li>
					<pre class="brush: plain">
						Sec-WebSocket-Accept = Base64Encode(SHA-1(Sec-WebSocket-Key + 
						  "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"))</pre>
					<ul>
						<li><code>SHA-1</code> &ndash; hashing function</li>
						<li><code>Base64Encode</code> &ndash; Base64 encoding function</li>
						<li><code>"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</code> &ndash; magic number</li>
					</ul>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Data Transfer</h1>
			</hgroup>
			<ul class="xx-small">
				<li>After a successful connection upgrade</li>
				<ul>
					<li>socket between the client and the "resource" at the server is established</li>
					<li>client and the server can both read and write from/to the socket</li>
					<li>No HTTP headers overhead</li>
				</ul>
				<li>Data Framing</li>
				<ul>
					<li>Data transmitted in TCP packets (see RFC6455: <span class="h-ref" id="ietf-ws-frame"></span>)</li>
					<li>Contains payload length, closing frame, ping, pong, type of data (text/binary), etc. and payload (message data)</li>
					<div style="zoom: 0.85">
						<pre class="brush: plain; class-name: tight; gutter: false;">

                          0                   1                   2                   3
					      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
					     +-+-+-+-+-------+-+-------------+-------------------------------+
					     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
					     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
					     |N|V|V|V|       |S|             |   (if payload len==126/127)   |
					     | |1|2|3|       |K|             |                               |
					     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
					     |     Extended payload length continued, if payload len == 127  |
					     + - - - - - - - - - - - - - - - +-------------------------------+
					     |                               |Masking-key, if MASK set to 1  |
					     +-------------------------------+-------------------------------+
					     | Masking-key (continued)       |          Payload Data         |
					     +-------------------------------- - - - - - - - - - - - - - - - +
					     :                     Payload Data continued ...                :
					     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
					     |                     Payload Data continued ...                |
					     +---------------------------------------------------------------+							
						</pre>
					</div>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Frame and Message</h1>
			</hgroup>
			<ul class="xx-small">
				<li>Frame</li>
				<ul>
					<li>The smallest unit of communication, composed of a header and a paylod</li>
					<li>Payload carries all or part of a message</li>
				</ul>
				<li>Message</li>
				<ul>
					<li>A sequence of frames that map to a logical application message</li>
					<li>Messages decomposition into frames is done by client and server framing code</li>
					<li>Application is unaware of frames but only application messages</li>
				</ul>
				<li>Frame on-the-wire</li>
				<ul>
					<li><code>FIN</code> &ndash; indication whether the frame is final in the message</li>
					<li><code>opcode</code> &ndash; type of frame: (text, binary, control frame, ping, pong)</li>
					<li>Mask bit indicates if the payload is masked (from client to server only)</li>
					<li>Payload length</li>
					<li>Masking key contains 32-bit key to mask the payload (if mask bit is set)</li>
					<li>Payload application data</li> 
				</ul>
			</ul>
		</div>

		<!-- https://tools.ietf.org/html/rfc6455#section-10.3 -->
		<!-- <div class="slide">
			<hgroup>
				<h1>Attacks on Infrastructure</h1>
			</hgroup>
			<ul class="xx-small">
				<li>Proxy cache poisoning</li>
				<ul>
					<li>Client establishes a connection to a server under an attacker's control</li>
					<li>Client sends <code>upgrade</code> on the HTTP connection</li>
					<li>Client sends data over upgraded connection that look like HTTP GET</li>
					<ul>
						<li>GET for a specific known resource</li>
					</ul>
					<li>Server responds with resource</li>
					<ul>
						<li>The resource would be a malicious script</li>
					</ul>
					<li>The resource is cached by one or more intermediaries, thus poisoning the cache</li>
					<li>Attacker can run malicious script on other origins</li>
				</ul>
				<li>The data must be masked from client to the server</li>
				<ul>
					<li>Attacker does not have control on how the data being sent appears on the wire</li>
					<li>Attacker cannot construct a message that could be misinterpreted by an intermediary as an HTTP request</li>
				</ul>
				<li>Clients must chose masking key for each frame</li>
				<ul>
					<li>The key cannot be predicted by end application that provide the data</li>
				</ul> 
			</ul>
		</div> -->

		<div class="slide">
			<hgroup>
				<h1>Head-of-line Blocking</h1>
			</hgroup>
			<ul class="xx-small">
				<li>Head-of-line blocking recall</li>
				<ul>
					<li>Second request needs to wait for the first request to finish</li>
					<li>See <a href="https://mdw.vitvar.com/lecture3.html#/18/v1">HTTP Pipelining in AM1</a> for more details</li>
				</ul>
				<li>WebSocket</li>
				<ul>
					<li>Large messages can cause the head of line blocking on the client</li>
					<li>Messages can be split into more frames</li>
					<li>But frames cannot be interleaved</li>
				</ul>
				<li class="no-bullet">&rArr; A large message with more frames may block frames of other messages</li>
				<li>You need to be careful of payload size of each message</li>
				<ul>
					<li>You should:</li>
          <ul>
             <li>split large message into multiple application messages</li>
             <li>monitor amount of messages in the client's buffer</li>
             <li>send data when buffer is empty</li>
           </ul>
				</ul>
				<li>Each WebSocket connection requires a dedicated TCP connection</li>
				<ul>
					<li>Problem with HTTP/1.x due to a restricted number of connections per origin</li>
				</ul>
			</ul>
		</div>

    <div class="slide">
			<hgroup>
				<h1>WebSocket Browser API</h1>
			</hgroup>
			<ul class="xx-small">
				<li>Client-side API</li>
				<ul>
					<li>clients to utilize WebSocket, supported by all modern browsers</li>
					<li>Hides complexity of WebSocket protocol for the developer</li>
				</ul>
				<li>JavaScript example</li>
				<pre class="brush: javascript; class-name: tight">
					// ws is a new URL schema for WebSocket protocol; 'chat' is a sub-protocol
					var connection = new WebSocket('ws://server.example.org/chat', 'chat');

					// When the connection is open, send some data to the server
					connection.onopen = function () {
					  // connection.protocol contains sub-protocol selected by the server
					  console.log('subprotocol is: ' + connection.protocol); 
					  connection.send('data'); 
					};
					
					// Log errors
					connection.onerror = function (error) {
					  console.log('WebSocket Error ' + error);
					};
					
					// Log messages from the server
					connection.onmessage = function (e) {
					  console.log('Server: ' + e.data);
					};
					
					...
					
					// closes the connection
					connection.close()</pre>
			</ul>
		</div>

    <div class="slide">
			<hgroup>
				<h1>Avoid Head of Line Blocking</h1>
			</hgroup>
			<ul class="xx-small">
				<li>Example code to monitor a client buffer size</li>
        <pre class="brush: javascript; class-name: tight">
          var ws = new WebSocket('wss://example.com/socket');

          ws.onopen = function () {
            subscribeToApplicationUpdates(function(evt) { 
              if (ws.bufferedAmount == 0) 
                ws.send(evt.data); 
            });
          };          
        </pre>
        <ul>
          <li>A call to <code>send</code> is asynchronous</li>
          <li>Multiple calls to <code>send</code> will fill the client buffer</li>
        </ul>
			</ul>
		</div>


		<div class="slide">
			<hgroup>
				<h1>WebSocket Infrastructure</h1>
			</hgroup>
			<ul class="xx-small">
				<li>HTTP optimized for short transfers</li>
				<ul>
					<li>intermediaries are configured to timeout idle HTTP connections quickly</li>
					<li>This can be a problem for long-lived WebSocket connections</li>
				</ul>
				<li>We cannot control</li>
				<ul>
					<li>Client's network, some networks may block WebSocket traffic</li>
					<ul>
						<li>We need a fallback strategy</li>
					</ul>
					<li>Proxies on the external network</li>
					<ul>
						<li>TLS may help, tunneling over secure end-to-end connection, WebSocket traffic can bypass intermediaries</li>
					</ul>
				</ul>
				<li>We can control our infrastructure</li>
				<ul>
					<li>For example, set tunnel timeout to 1 hour on HAProxy</li>
					<pre class="brush: plain">
					defaults http
						timeout connect 30s
						timeout client  30s
						timeout server  30s
						timeout tunnel  1h</pre>				
				</ul>
			</ul>
		</div>

		<!-- <div class="slide">
			<hgroup>
				<h1>Sockets.IO</h1>
			</hgroup>
			<ul class="x-small spacing">
				<li>Many options for streaming</li>
				<ul>
					<li>long-polling, streaming, iframe, WebSockets</li>
					<li>Not all browsers support WebSockets</li>
					<li><span id="socket.io" class="h-ref"></span> &ndash; a layer providing a unified API</li>
				</ul>
				<li>Sockets.IO</li>
				<ul>
					<li>API and JavaScript implementation</li>
					<li>checks the availability of WebSocket protocol</li>
					<ul>
						<li>fallback to long-polling or other technologies when not available</li>
					</ul>
				</ul>
				<pre class="brush: javascript">
					// creates a new socket
					var socket = new io.Socket(); 
					
					// event handlers
					socket.on('connect', function(){ 
					  socket.send('hi!'); 
					}) 
					socket.on('message', function(data){ 
					  alert(data);
					})
					socket.on('disconnect', function(){})</pre>
			</ul>
		</div> -->
		
	</section>
	
	<!-- <div class="slide outline"></div>	
	
	<section>
		<header>M-JPEG</header>
		
		<div class="slide">
			<hgroup>
				<h1>Streaming video</h1>
			</hgroup>
			<ul class="x-small">
				<li>Webcams, IP or USB</li>
				<ul>
					<li>Play video stream using RTSP or M-JPEG</li>
					<li>RTSP (Realtime Streaming Protocol) defines sequences to control palying multimedia</li>
				</ul>
				<li>Sample tasks</li>
				<ul>
					<li>Add video stream to a web page</li>
					<ul>
						<li><code>video</code> HTML5 element</li>
					</ul>
					<li>Capture frames from the camera and process them</li>
					<ul>
						<li>Capture frames in a specific format such as JPG</li>
						<li>Specific software to capture frames, typically OpenCV</li>
					</ul>
					<li>Add annotation to video and expose as video stream</li>
					<ul>
						<li>Detect objects in pictures &ndash; machine learning/deep learning</li>
						<li>Mark objects and expose frames as video to the client</li>
						<li>Create RTSP stream by using e.g. GStreamer or FFMPEG</li>
						<li>Create stream of JPG images, so called M-JPEG<br /> and push them to the client</li>
					</ul>
				</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>M-JPEG</h1>
			</hgroup>
			<ul class="x-small">
				<li>M-JPEG - Motion JPEG</li>
				<ul>
					<li>Video compression format, each frame is represented as a JPEG image</li>
					<li>Widely used by cameras today</li>
					<li>Uses HTTP response stream of <code>multipart/x-mixed-replace</code> content type</li>
				</ul>
				<li>Example HTTP response to a M-JPEG request</li>
				<pre class="brush: bash">
					HTTP/1.1 200 OK
					Content-Type: multipart/x-mixed-replace; boundary=imgboundary

					--imgboundary
					Content-Type: image/jpeg
					Content-length: 5432

					[image 1 encoded jpeg data]

					--imgboundary
					Content-Type: image/jpeg
					Content-length: 54335

					[image 2 encoded jpeg data]

					...					
				  </pre>
		</div> -->

	</section>

<!--	<div class="slide outline"></div>

	<section>
		<header>WebRTC</header>

		<div class="slide">
			<hgroup>
				<h1>WebRTC</h1>
			</hgroup>
			<ul class="small">
				<li>Web Real-Time Communication</li>
				<ul>
					<li>API to exchange media and arbitrary data between peers inside Web pages</li>
					<li>It uses peer-to-peer principles</li>
					<li>Supported by Google, Mozilla, Microsoft, Opera</li>
				</ul>
				<li>Specifications</li>
				<ul>
					<li><span id="webrtc-ietf" class="h-ref"></span></li>
					<li><span id="webrtc-w3c" class="h-ref"></span></li>
				</ul>
				<li>History</li>
				<ul>
					<li>Google acquires company Global IP Solutions (GIPS) in 2010</li>
					<li>GIPS developed underlying technology (codecs, echo cancellation techniques), released as open source</li>
					<li>Google promoted the work around GIPS to W3C and IETF</li>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>WebRTC Main Tasks</h1>
			</hgroup>
			<ul class="small">
				<li>Acquiring audio and video</li>
				<ul>
					<li>JavaScript API: <code>MediaStream</code> (aka getUserMedia)</li>
				</ul>
				<li>Communicating audio and video</li>
				<ul>
					<li>JavaScript API: <code>RTCPeerConnection</code></li>
				</ul>
				<li>Communicating arbitrary data</li>
				<ul>
					<li>JavaScript API: <code>RTCDataChannel</code></li>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>GetUserMedia</h1>
			</hgroup>
			<ul class="x-small">
				<li>JavaScript code</li>
				<pre class="brush: javascript">
						var constraints = {video: true};

						function successCallback(stream) {
						  var video = document.querySelector("video");
						  video.src = window.URL.createObjectURL(stream);
						}

						function errorCallback(error) {
						  console.log("navigator.getUserMedia error: ", error);
						}

						navigator.getUserMedia(constraints, successCallback, errorCallback);
						</pre>
				<li>Constraints</li>
				<ul>
					<li>Control the contents of the MediaStream</li>
					<li>Media type, resolution, frame rate</li>
				</ul>
				<li>JavaScript app can read and manipulate the stream.</li>
				<li>It is also possible to acquire <b>audio</b> as well as <b>screen capture.</b></li>
		</div>

		<div class="slide">
			<hgroup>
				<h1>RTCPeerConnection</h1>
			</hgroup>
			<ul class="small">
				<li>Allows to communicate media stream acquired by <code>getUserMedia</code></li>
				<ul>
					<li>Video chat, audio chat, screen sharing</li>
				</ul>
				<li>Some capabilities of <code>RTCPeerConnection</code></li>
				<ul>
					<li>Signal processing</li>
					<li>Code handling</li>
					<li>Peer to peer communication</li>
					<li>Security</li>
					<li>Bandwidth management</li>
				</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>WebRTC Architecture</h1>
			</hgroup>
			<ul>
				<img src="img/webrtc-arch.png" style="padding-top: 10px"></img>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Communication</h1>
			</hgroup>
			<ul class="small">
				<li>Two phases</li>
				<ol>
					<li><b>Signaling</b></li>
					<ul>
						<li>WebRTC defines <b>abstract signalling</b></li>
						<li>apps can use any singaling protocol, can use any such as SIP, XMPP, or custom using XHR or Websockets</li>
					</ul>
					<li><b>Exchange of real-time</b> data in peer-to-peer manner</li>
				</ol>
				<li>Abstract signaling</li>
				<ul>
					<li>Need to exhange <b>session description</b> objects</li>
					<ul>
						<li>Formats, codecs the peers want to use</li>
						<li>Network information for peer-to-peer communication</li>
						<li>This information is captured as <code>RTCSessionDescription</code> (also SDP) structure</li>
					</ul>
					<li>Any messaging mechanism and protocol</li>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>SIP and SDP</h1>
			</hgroup>
			<ul class="xx-small">
				<li>Standards</li>
				<ul>
					<li>SIP &ndash; Session Initiation Protocol, protocol to establish and modify sessions.</li>
					<li>SDP &ndash; Session Description Protocol, describes media for a session, defined in <span class="h-ref" id="ietf-sdp"></span></li>
				</ul>
				<li>SDP Example</li>
				<pre class="brush: plain; gutter: 'false'">
					v=0
					o=- 7614219274584779017 2 IN IP4 127.0.0.1
					s=-
					t=0 0
					a=group:BUNDLE audio video
					a=msid-semantic: WMS
					m=audio 1 RTP/SAVPF 111 103 104 0 8 107 106 105 13 126
					c=IN IP4 0.0.0.0
					a=rtcp:1 IN IP4 0.0.0.0
					a=ice-ufrag:W2TGCZw2NZHuwlnf
					a=ice-pwd:xdQEccP40E+P0L5qTyzDgfmW
					a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
					a=mid:audio
					a=rtcp-mux
					a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:9c1AHz27dZ9xPI91YNfSlI67/EMkjHHIHORiClQe
					a=rtpmap:111 opus/48000/2
					...</pre>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Signaling Diagram</h1>
			</hgroup>
			<ul>
				<img src="img/jsep.png" style="padding-top: 40px; zoom: 0.8"></img>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>JavaScript Session Establishment (JSEP)</h1>
			</hgroup>
			<ul class="x-small">
				<li>JSEP is a protocol to create a session between two parties</li>
				<ul>
					<li>The interface needed by an application to deal with the negotiated local and remote session descriptions</li>
				</ul>
				<li>JSEP steps between Alice and Bob</li>
				<ol>
					<li>Alice creates an offer that contains her local SDP.</li>
					<li>Alice attaches that offer to <code>RTCPeerConnection</code> object.</li>
					<li>Alice sends the offer to a singaling server using custom-built mechanism (WebSocket, XHR, etc.)</li>
					<li>Bob receives Alice's offer from the signaling server</li>
					<li>Bob creates an answer using his local SDP.</li>
					<li>Bob attaches his answer along with Alice's offer to his own <code>RTCPeerConnection</code> object.</li>
					<li>Bob returns his answer to the singaling server.</li>
					<li>Alice receives Bob's offer from the singaling server.</li>
				</ol>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>Interactive Connectivity Establishment</h1>
			</hgroup>
			<ul class="x-small">
				<li>ICE &ndash; Interactive Connectivity Establishment</li>
				<ul>
					<li>Allows WebRTC to overcome complexities of real-world networking</li>
					<li>Finds the best path to connect peers such as</li>
					<ul>
						<li>direct P2P communication.</li>
						<li>by using STUN or TURN servers.</li>
					</ul>
				</ul>
				<li>STUN &ndash; Session Traversal Utilities for NAT</li>
				<ul>
					<li>Allows to discover the presence of a NAT server.</li>
					<li>Allows to discover the public IP address and a port that the NAT has allocated for UDP flows.</li>
					<li>It is provided as a third-party network server (STUN server) located on the public side of the NAT.</li>
				</ul>
				<li>TURN &ndash; Traversal Using Relays around NAT</li>
				<ul>
					<li>Communication relay for hosts behind NAT when STUN does not work.</li>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>STUN</h1>
			</hgroup>
			<ul>
				<img src="img/stun.png" style="padding-top: 50px; padding-bottom: 50px; zoom: 0.6"></img>
				<ul>
					<ul>
						<li>STUN is a simple server, cheap to run</li>
						<li>Data flows peer-to-peer</li>
					</ul>
				</ul>
			</ul>
		</div>

		<div class="slide">
			<hgroup>
				<h1>TURN</h1>
			</hgroup>
			<ul>
				<img src="img/turn.png" style="padding-top: 50px; padding-bottom: 50px; zoom: 0.6"></img>
				<ul>
					<ul>
						<li>a cloud fallback when peer-to-peer does not work</li>
						<li>data sent via a relay server, uses server bandwidth</li>
					</ul>
				</ul>
			</ul>
		</div>
	</section> -->


</body>

</html>